unit myPan6Unit;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Math;

type
  TMatrix2D = array of array of Double;
  TMatrix3D = array of array of array of Double;
  TUserData = record
    pan: TMatrix2D;
    msi: TMatrix3D;
  end;

function myPan6(sol: TMatrix2D; userdata: TUserData; out ps: TMatrix3D): TArray<Double>;
function CreateMatrix2D(rows, cols: Integer): TMatrix2D;
function CreateMatrix3D(rows, cols, depth: Integer): TMatrix3D;
function ImFilter(image: TMatrix2D; kernel: TMatrix2D; mode: string): TMatrix2D;
function RMSE(A, B: TMatrix3D): Double;
function Cat3(pan: TMatrix2D): TMatrix3D;

implementation

function CreateMatrix2D(rows, cols: Integer): TMatrix2D;
var
  i: Integer;
begin
  SetLength(Result, rows);
  for i := 0 to rows - 1 do
    SetLength(Result[i], cols);
end;

function CreateMatrix3D(rows, cols, depth: Integer): TMatrix3D;
var
  i, j: Integer;
begin
  SetLength(Result, rows);
  for i := 0 to rows - 1 do
  begin
    SetLength(Result[i], cols);
    for j := 0 to cols - 1 do
      SetLength(Result[i][j], depth);
  end;
end;

function ImFilter(image: TMatrix2D; kernel: TMatrix2D; mode: string): TMatrix2D;
var
  rows, cols, kRows, kCols: Integer;
  i, j, ki, kj, ii, jj: Integer;
  sum: Double;
begin
  rows := Length(image);
  cols := Length(image[0]);
  kRows := Length(kernel);
  kCols := Length(kernel[0]);
  
  Result := CreateMatrix2D(rows, cols);
  
  for i := 0 to rows - 1 do
  begin
    for j := 0 to cols - 1 do
    begin
      sum := 0.0;
      for ki := 0 to kRows - 1 do
      begin
        for kj := 0 to kCols - 1 do
        begin
          ii := i + ki - kRows div 2;
          jj := j + kj - kCols div 2;
          
          // Replicate boundary handling
          if ii < 0 then ii := 0;
          if ii >= rows then ii := rows - 1;
          if jj < 0 then jj := 0;
          if jj >= cols then jj := cols - 1;
          
          sum := sum + image[ii][jj] * kernel[ki][kj];
        end;
      end;
      Result[i][j] := sum;
    end;
  end;
end;

function RMSE(A, B: TMatrix3D): Double;
var
  i, j, k: Integer;
  sum: Double;
  count: Integer;
  diff: Double;
begin
  sum := 0.0;
  count := 0;
  
  for i := 0 to Length(A) - 1 do
  begin
    for j := 0 to Length(A[0]) - 1 do
    begin
      for k := 0 to Length(A[0][0]) - 1 do
      begin
        diff := A[i][j][k] - B[i][j][k];
        sum := sum + diff * diff;
        Inc(count);
      end;
    end;
  end;
  
  Result := Sqrt(sum / count);
end;

function Cat3(pan: TMatrix2D): TMatrix3D;
var
  i, j: Integer;
  rows, cols: Integer;
begin
  rows := Length(pan);
  cols := Length(pan[0]);
  Result := CreateMatrix3D(rows, cols, 3);
  
  for i := 0 to rows - 1 do
  begin
    for j := 0 to cols - 1 do
    begin
      Result[i][j][0] := pan[i][j];
      Result[i][j][1] := pan[i][j];
      Result[i][j][2] := pan[i][j];
    end;
  end;
end;

function myPan6(sol: TMatrix2D; userdata: TUserData; out ps: TMatrix3D): TArray<Double>;
var
  pan: TMatrix2D;
  msi: TMatrix3D;
  n, i, j: Integer;
  k: TMatrix2D;
  kernelSum: Double;
  low, hi: TMatrix2D;
  w: array of Double;
  rmse1, rmse2: Double;
  panCat: TMatrix3D;
begin
  // Convert userdata to local variables
  pan := userdata.pan;
  msi := userdata.msi;
  
  n := Length(sol);
  SetLength(Result, n);
  
  // Initialize ps with msi (memory)
  ps := CreateMatrix3D(Length(msi), Length(msi[0]), Length(msi[0][0]));
  for i := 0 to Length(msi) - 1 do
    for j := 0 to Length(msi[0]) - 1 do
      for var k := 0 to Length(msi[0][0]) - 1 do
        ps[i][j][k] := msi[i][j][k];
  
  // Initialize all outputs to infinity
  for i := 0 to n - 1 do
    Result[i] := Infinity;
  
  for i := 0 to n - 1 do
  begin
    // Extract and reshape kernel k from sol(i,1:9)
    k := CreateMatrix2D(3, 3);
    for var row := 0 to 2 do
      for var col := 0 to 2 do
        k[row][col] := sol[i][row * 3 + col];
    
    // Normalize kernel: k = k / sum(k(:))
    kernelSum := 0.0;
    for var row := 0 to 2 do
      for var col := 0 to 2 do
        kernelSum := kernelSum + k[row][col];
    
    if kernelSum <> 0.0 then
    begin
      for var row := 0 to 2 do
        for var col := 0 to 2 do
          k[row][col] := k[row][col] / kernelSum;
    end;
    
    // Apply filter
    low := ImFilter(pan, k, 'replicate');
    
    // Calculate high frequency component
    hi := CreateMatrix2D(Length(pan), Length(pan[0]));
    for var row := 0 to Length(pan) - 1 do
      for var col := 0 to Length(pan[0]) - 1 do
        hi[row][col] := pan[row][col] - low[row][col];
    
    // Extract weights w from sol(i,10:end)
    SetLength(w, Length(sol[i]) - 9);
    for j := 0 to Length(w) - 1 do
      w[j] := sol[i][j + 9];
    
    // Update ps for each band
    for j := 0 to 2 do
    begin
      for var row := 0 to Length(ps) - 1 do
      begin
        for var col := 0 to Length(ps[0]) - 1 do
        begin
          ps[row][col][j] := pan[row][col] + 
                            w[j] * (msi[row][col][j] - pan[row][col]) + 
                            w[j + 3] * hi[row][col];
        end;
      end;
    end;
    
    // Calculate RMSE
    rmse1 := RMSE(msi, ps);
    panCat := Cat3(pan);
    rmse2 := RMSE(panCat, ps);
    
    Result[i] := (rmse1 + rmse2) / 2.0;
  end;
end;

end.