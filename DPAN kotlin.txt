import kotlin.math.*

data class UserData(
    val pan: Array<Array<Double>>,
    val msi: Array<Array<Array<Double>>>
)

data class Result(
    val out: DoubleArray,
    val ps: Array<Array<Array<Double>>>
)

fun myPan6(sol: Array<DoubleArray>, userData: UserData): Result {
    val pan = userData.pan
    val msi = userData.msi
    val n = sol.size
    val out = DoubleArray(n) { Double.POSITIVE_INFINITY }
    
    // ps = msi (memory allocation - deep copy)
    val ps = Array(msi.size) { i ->
        Array(msi[i].size) { j ->
            Array(msi[i][j].size) { k ->
                msi[i][j][k]
            }
        }
    }
    
    for (i in 0 until n) {
        // Extract kernel k from first 9 elements
        val kFlat = sol[i].sliceArray(0..8)
        val k = Array(3) { row ->
            Array(3) { col ->
                kFlat[row * 3 + col]
            }
        }
        
        // Normalize kernel: k = k / sum(k)
        val kernelSum = k.sumOf { row -> row.sum() }
        for (row in k) {
            for (col in row.indices) {
                row[col] /= kernelSum
            }
        }
        
        // Apply filter: low = imfilter(pan, k, "replicate")
        val low = imfilter(pan, k, "replicate")
        
        // Calculate high frequency: hi = pan - low
        val hi = Array(pan.size) { row ->
            Array(pan[row].size) { col ->
                pan[row][col] - low[row][col]
            }
        }
        
        // Extract weights w from remaining elements
        val w = sol[i].sliceArray(9 until sol[i].size)
        
        // Apply pansharpening for each band
        for (j in 0..2) {
            for (row in ps.indices) {
                for (col in ps[row].indices) {
                    ps[row][col][j] = pan[row][col] + 
                                     w[j] * (msi[row][col][j] - pan[row][col]) + 
                                     w[j + 3] * hi[row][col]
                }
            }
        }
        
        // Calculate RMSE and store result
        val rmse1 = rmse(msi, ps)
        val rmse2 = rmse(createPanStack(pan), ps)
        out[i] = (rmse1 + rmse2) / 2.0
    }
    
    return Result(out, ps)
}

// Helper function to apply 2D filter with replicate border handling
fun imfilter(image: Array<Array<Double>>, kernel: Array<Array<Double>>, borderType: String): Array<Array<Double>> {
    val rows = image.size
    val cols = image[0].size
    val kRows = kernel.size
    val kCols = kernel[0].size
    val kCenterRow = kRows / 2
    val kCenterCol = kCols / 2
    
    val result = Array(rows) { Array(cols) { 0.0 } }
    
    for (i in 0 until rows) {
        for (j in 0 until cols) {
            var sum = 0.0
            for (ki in 0 until kRows) {
                for (kj in 0 until kCols) {
                    val imageRow = i + ki - kCenterRow
                    val imageCol = j + kj - kCenterCol
                    
                    // Handle replicate border
                    val clampedRow = imageRow.coerceIn(0, rows - 1)
                    val clampedCol = imageCol.coerceIn(0, cols - 1)
                    
                    sum += image[clampedRow][clampedCol] * kernel[ki][kj]
                }
            }
            result[i][j] = sum
        }
    }
    
    return result
}

// Helper function to calculate RMSE between two 3D arrays
fun rmse(array1: Array<Array<Array<Double>>>, array2: Array<Array<Array<Double>>>): Double {
    var sumSquaredDiff = 0.0
    var count = 0
    
    for (i in array1.indices) {
        for (j in array1[i].indices) {
            for (k in array1[i][j].indices) {
                val diff = array1[i][j][k] - array2[i][j][k]
                sumSquaredDiff += diff * diff
                count++
            }
        }
    }
    
    return sqrt(sumSquaredDiff / count)
}

// Helper function to create 3D array from 2D pan image (equivalent to cat(3,pan,pan,pan))
fun createPanStack(pan: Array<Array<Double>>): Array<Array<Array<Double>>> {
    return Array(pan.size) { i ->
        Array(pan[i].size) { j ->
            Array(3) { pan[i][j] }
        }
    }
}